---
title: "02-O-ana-calculate-user-error"
author: "Patrick Green & Ariel Marcy""
date: "12-03-2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```
# Calculate user error
Geometric morphometric studies usually require a lot of user-generated data and it's important to assess how much user error is created during the landmarking process. 

First, we visualize whether any outliers can be explained by mistakes in landmark placement (e.g. a point "falling through" the nasal to land on the inner basicranium).

Second, we compare the shape variation between 20 individuals, from a variety of different species, landmarked twice to calculate the intra-observer (i.e. digitizer) error.

### Load packages, functions, and data from previous steps
```{r message = FALSE}
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
source("../Functions/utilities.R")  # custom functions defined in utilities.R
load(file = "../Data/Processed/01-bilat-data-w-ERR.rda")
```

## 1) Check for outliers and fix landmarking errors
_geomorph_ comes with a handy function to check for outliers. Since our sample has a wide range of species, we decided to include the groups factor. This means the plotOutliers returns likely outliers for each genus instead of the group as a whole. When groups were not defined, only large species were returned as "outliers". 
```{r}
# Plot outliers by genus for small patch dataset
outliers <- plotOutliers(bY.shape, inspect.outliers = F)
```


### Visualize why they are outliers by looking at landmark vectors
We can examine the landmark placements in outliers as compared to the specimen closest to the median, based on the plots above. This allows us to determine if there were any major landmarking errors that might impact further analyses.

Genus abbreviatons and number of outliers were inserted where needed for each genus. This code was only used once: after all landmarks were captured and before the other major analyses were completed.

We wrote a function, `MatchSpecShape()` to help us visualize outlier shape information. The function returns the 3D shape of specimen of interest. We can use it to compare the outliers to the median specimen in its genus.
```{r}
plotRefToTarget(bY.shape[ , , outliers[1]], bY.shape[ , , outliers[10]])
plotRefToTarget(bY.shape[ , , outliers[1]], bY.shape[ , , outliers[10]], method = "vector")
plotRefToTarget(bY.shape[ , , outliers[2]], bY.shape[ , , outliers[10]], method = "vector")

```


**Repeat the above for each genus/patch protocol as needed. When landmarking errors are found, fix in Viewbox, export new coordinates, and begin again from script 01.** 

## 2) Calculate intra-observer error
Now that the shape data have been processed via GPA + bilateral symmetry and corrected for obvious landmarking errors, we can separate the data intended to measure user error from the main data for the remaining analyses. 

Make the datasets to be used for the rest of the analyses.
```{r}
main <- which(sp.info$Rep == "non")
shape <- bY.shape[, , main]
info <- sp.info[main, ]
```

Create an error measurement dataset for both protocols that includes replicates and the specimens they duplicated (i.e. each CatNum should have two entries, one labeled "ERR", and one labled "non"). These data will be used to calculate user error. 
```{r}
# Find index for both versions of specimens with replicates using rep.spec list make in script 01.
rep.CatNums <- as.character(str_sub(rep.spec, 9, -1))  # isolate CatNum
error.data <- which(sp.info$CatNum %in% rep.CatNums)  # error.data is the same for small and big patch protocols, tested with all.equal()



# Subset shape and metadata tables for each protcol
error.data <- which(sp.info$Rep == "ERR")
err.shape <- bY.shape[, , error.data]
err.info <- sp.info[error.data, ]
```

### Calculate user error aka Repeatability
Here, we calculate repeatability for each patch protocol from formulas 1-3 in Fruciano 2016. The function `RepAbility()` was modified from Marcy et al. 2018.
```{r}

RepAbility <- function(coords, ids, n.Rep, print = TRUE, export = FALSE, filename = NULL) {
        # Calculates repeatability (R) for GMM studies.
        #
        # Args:
        #    coords: a 3D array (p x k X n) of shape coordinates.
        #    ids: a list of identifiers used to find replicates, e.g. CatNum.
        #    n.Rep: number of repetitions taken for each individual
        #    print: if TRUE, prints ANOVA and R to the console.
        #    export: if TRUE, exports ANOVA and R to .csv.
        #    filename: the filename used to save the .csv file.
        #
        # Returns:
        #    A table with the ANOVA and the value of R, repeatability.
        
        # Calculations from formulas 1-3 in Fruciano 2016
        r.gdf <- geomorph.data.frame(coords = coords, ind = factor(ids))
        rep.er <- procD.lm(coords ~ ind, data = r.gdf, iter = 999)
        S.sq.A <- ((rep.er$aov.table$MS[1] - rep.er$aov.table$MS[2]) / n.Rep)  # among-individuals variance component: 
        S.sq.W <- rep.er$aov.table$MS[2]  # within-individual variance
        R <- S.sq.A / (S.sq.W + S.sq.A)  # analogue of the intraclass correlation coeffiecent
        
        table <- rep.er$aov.table
        table$Repeatability <- R
        
        if (print) {
                print(rep.er$aov.table)
                cat("\n","Repeatability =", R)
        }
        if (export) {
                write.csv(table, file = paste(filename, ".csv", sep = ""))
        } else {
                return (table)
        }
}


# Note: n.rep = 2 in this case because we measured each specimen twice
RepAbility(bY.shape, sp.info$CatNum, n.Rep = 2)  
```

### Save intermediate data 
These are the main datasets for both protocols without replicates
```{r}
save(shape, info, sm.shape, sm.info, file = "../Data/Processed/02-main-data-both-protocols.rda")
```
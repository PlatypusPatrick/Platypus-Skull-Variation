---
title: "02-O-ana-Landmarked-data-error-and-allometry-checks"
author: "Patrick Green & Areil Marcy"
date: "18-04-2019"
output: html_document
---

### Converting information from Viewbox into shape and metadata
This code extracts two kinds of data from an excel sheet of coordinates exported from Viewbox, a 3D landmarking software (dHAL software, Kifissia, Greece; www.dhal.com; Polychronis et al. 2013). The first is the shape information from the 3D coordinates. The second is the metadata stored in the filename for each specimen.

We found in Marcy et al. 2018, that using bilateral shape data improved the reliability of landmarking for small 3D-scanned skulls. Therefore we prepare the shape data to run _geomorph_'s `bilat.symmetry()` function.

Almost all upcoming analyses are done in the geometric morphometric R package, _geomorph_(Adams 2016; Adams & Otarola-Castillo 2013).

### Load packages
```{r}
library(dplyr)
library(stringr)
library(stringi)
library(data.table)
library(geomorph)
```

## Prepare shape data for analyses in _geomorph_
Viewbox exports the data as a 2D array with specimens as columns and X, Y, and Z coordinates as rows for landmark. For _geomorph_, we need to convert this into a 3D array where each specimen has its own 2D array of 3 columns for XYZ coordinates and a row for each landmark. In other words, a 3D array has dimensions (p x k x n), where p is the number of landmarks, k is the dimension (2 or 3), and n is the number of specimens.

We also need to extract the metadata contained in the specimen filenames (exported as column names) and preserve their order so that the metadata matches the order of specimens in the shape data.

### Convert to 3D array
Here, we convert the coordinates into a 3D array for _geomorph_. Importantly, we need to remove the 1st column of landmark names. Following this is a 3D check of the landmarked positions. 
```{r}
data.raw <- read.csv("../1_Data (original data)/1_Raw/02_O_ana_-_Landmark_Data.csv", header = T)

data <- data.raw[, 2:(dim(data.raw)[2])]  # removes LM names for geomorph
data <- t(data)
A_ERR <- arrayspecs(data, 135, 3,sep = NULL)  # convert to 3D array w 405 pts & 3D coords

plot3d(A_ERR[,,1], asp=FALSE) #Check the landmarks have come through ok
```

## Extract metadata table from specimen filenames in shape array
The coordinate data is just shape data unless we can extract any information the landmarker put in each specimen's filename. Starting here, we make a metadata table with specimens in the same order as their coordinates for future analyses. 

### Fix naming of replicate filenames (included to measure user error)
Interspersed throughout the data collection process are ten landmarked specimens, that have been landmarked twice. Their specimen names included "_ERR", however, not always in the same place in the filename. 

We correct the naming scheme to be machine-readable and in the process create a list of specimen names which were landmarked twice. 
```{r}
# Detect replicates
names <- dimnames(A_ERR)[[3]]
isrep <- which(str_detect(names, "_ERR"))

# Removing Replicates
specimens <- c(1:length(dimnames(A_ERR)[[3]]))
notrep <- is.na(match(specimens, isrep))
A <- A_ERR[ , ,notrep]
```

### Run function to scrape filenames for metadata
The `WriteMetadata()` function makes a metadata table in the same order of specimens in the shape array, A, created from Viewbox's coordinate data. The function reads the specimen filenames from the 3D array and uses a character vector, cols, to names the attributes separated by "_" in the specimen filenames. It returns a matrix of data ordered by specimen with columns for each attribute.

## Remove "burn-in" specimens from dataset to reduce user error
First, to reduce user error, Patrick Green has landmarked 10 specimens to familiarize himself with the template and re-landmarked those 10 later on. This is close to the standard "burn-in" number recommended by GMM experts like _geomorph_ co-author, Dr Emma Sherratt (see her guides [here](http://www.emmasherratt.com/morphometrics/)).

In this dataset, the filenames look like: O_ana_MV_C12345_non for genus, species, museum code, catalog number, replicate status. Therefore, the corresponding cols vector is as below:
```{r}
WriteMetadata <- function(threeD.array, cols) {
        # Makes metadata table from specimen filenames for shape coordinates.
        #
        # Args:
        #    threeD.array: 3D array (p x k x n), where p is the number of landmarks, k is the dimension (3), and n is the number of specimens. Assumes the 1st column of landmark names has been removed. 
        #    cols: a character vector of column names of length n-1, where n is the number of underscores separating metadata information in the specimen filenames. Assumes filenames contain information in the same order and the appropriate names are given in this order in cols. 
        #
        # Returns: 
        #    A dataframe containing the metadata for each specimen in the same order as specimens in the 3D array of shape data.
        
        # Remove 'ind' that bilat.symmetry() appends to specimen names
        names <- gsub("ind", "", dimnames(threeD.array)[[3]])
        names <- gsub("_non","",names)
        names <- gsub("_ERR", "",names)
        
        # Convert name vectors into data frame
        categories <- strsplit(names, "_") 
        my.classifiers <- matrix(unlist(categories), ncol = length(cols), byrow = T) 
        colnames(my.classifiers) <- cols
        sp.info <- as.data.frame(my.classifiers)
        
        return(sp.info)
}

cols = c("Genus", "Species","Museum", "CatNum")
sp.info <- WriteMetadata(A, cols)

# Add special columns (requires 'Genus' 'Species' & 'CatNum')
sp.info$Taxa <- paste(str_sub(sp.info$Genus, 1, 1), str_sub(sp.info$Species, 1, 3), sep = "_")  # turns Ornithorhynchus anatinus into O_ana
sp.info$All <- with(sp.info, interaction(Genus, Species, Museum, CatNum, sep = "_"))  # required to run geomorph's bilat.symmetry()
```

### Create shape matrices for each patch protocol
```{r}
# Extract landmark point names
pt.names <-as.vector(data.raw[, 1])  # gets 3D point names from Viewbox
no.XYZ <- str_sub(pt.names, 3,-1)  # removes XYZ appended by Viewbox
no.XYZ.2 <- str_remove(pt.names, " [XYZ]")
u.pt.names<- unique(no.XYZ)  # returns unique point and curve names
```

### Run GPA and bilateral symmetry
Because we already slid our curve semi-landmarks and patch semi-landmarks in Viewbox, we pass their coordinates to _geomorph_ as if they are fixed landmarks. This avoids "over-sliding" the shape data. 
```{r}
Y <- gpagen(A, Proj = TRUE, ProcD = TRUE)
```

### Add centroid size from gpagen() to metadata
Simply join the centroid size given by `gpagen()` to the metadata table for each dataset. These data will be used later to quantify allometry.
```{r}
#Check that metadata and Csize match - this should return "TRUE" for all
names(Y$Csize)==sp.info$All

sp.info$Csize <- unname(Y$Csize)
```

### Prepare data for running `bilat.symmetry()`
To use _geomorph_'s `bilat.symmetry()` function, we needed to write a function, `FindPairs()` to find the bilateral landmark pairs. We assumed the user followed the following rules:

1. For bilateral names, "R" and "L" designate sides at very end of the landmark's name.
2. For curve points, "1", "2", "3", etc ascend in one direction, with bilateral curves sharing the same direction (e.g. numbers go up Anterior -> Posterior on both sides).
3. For patches, bilateral points should have the same point number.
```{r}
FindPairs <- function(pt.names){
       # Creates table of paired bilateral landmarks for bilat.symmetry().
       #
       # Args:
       #   pt.names: a character vector of landmark names.
       #
       # Returns:
       #   2 column data table of paired landmarks ready for geomorph's bilat.symmetry()'s land.pair argument.

       pairs <- NULL

       # Removes R and L designations so pairs can be detected
       no.side.names <- gsub("_R_", "_", pt.names)
       no.side.names <- gsub("_L_", "_", no.side.names)

       # Checks if point has a pair and if so, their index #s are paired
       for(i in unique(no.side.names)){
               index <- which(no.side.names == i)
               if (length(index) == 2) {
                       pairs <- rbind(pairs, t(index))
               }
       }
       return(pairs)
}

# Make landmark pair tables for each protocol
land.pairs <- FindPairs(u.pt.names)
```

### Run bilateral GPA
Now we are ready to re-run the generalized Procrustes alignment using bilateral landmark designations and extract the symmetric component of shape.  

## Summarize results from bilateral symmetry analyses
The bilateral results may be relevant for researchers interested in how much variation can be explained by symmetric variation among specimens, asymmetric variation among specimens, and fluctating asymmetry within specimens. 
```{r}
# Perform bilateral procrustes alignment on each patch protocol
biY <- bilat.symmetry(Y$coords, ind = sp.info$All, object.sym = T, replicate = NULL, side = NULL, land.pairs = land.pairs)

# Extract symmetric component of shape data
bY.shape <- biY$symm.shape  # analogous to Y$coords, where Y is the output of gpagen()

dimnames(biY$symm.shape) #Double checking the names

names(Y$Csize)

summary(biY)
```

## Calculate user error
Geometric morphometric studies usually require a lot of user-generated data and it's important to assess how much user error is created during the landmarking process. 

Here we visualize whether any outliers can be explained by mistakes in landmark placement (e.g. a point "falling through" the nasal to land on the inner basicranium).

### Check for outliers and fix landmarking errors
_geomorph_ comes with a handy function to check for outliers. Since our sample has a wide range of species, we decided to include the groups factor. This means the plotOutliers returns likely outliers for each genus instead of the group as a whole. When groups were not defined, only large species were returned as "outliers". 
```{r}
# Plot outliers by genus for small patch dataset
outliers <- plotOutliers(bY.shape, inspect.outliers = F)
```

### Visualize why they are outliers by looking at landmark vectors
We can examine the landmark placements in outliers as compared to the specimen closest to the median, based on the plots above. This allows us to determine if there were any major landmarking errors that might impact further analyses.

## Visualize outlier shape information. The block below returns the 3D shape of specimen of interest. We can use it to compare the outliers to the median specimen in its genus.
```{r}
# Find the mean specimen
meanspec=unname(findMeanSpec(bY.shape))
summary(meanspec)

par <- gridPar(pt.bg="pink", pt.size = 1)

#Comepare to mean specimen to outliers
dimnames(bY.shape)  #to get specimen order
plotRefToTarget(bY.shape[ , , meanspec], bY.shape[ , , 56], method = "vector", gridPars = par )
plotRefToTarget(bY.shape[ , , meanspec], bY.shape[ , , 29], method = "vector", gridPars = par )
```

### Align the specimen metadata with the coordinates for allometry analyses
```{r}
#Ensure that sp.infor and bY.shape have the specimens in the same order, which they do not by default because bilat.symm changes the order.
#Secondly take out the "ind" that is left over from the bilat symm operation; this makes the dimnames comparable to sp.info$All
dimnames(bY.shape)[[3]] <- sub(".*ind", "", dimnames(bY.shape)[[3]])

#If the below gives numbers but no NA, we are OK to re-order
match(dimnames(bY.shape)[[3]],sp.info$All)

#Here it is important that you match dimnames with sp.info$All, not the other way around
sp.infoOrdered <- sp.info[match(dimnames(bY.shape)[[3]],sp.info$All),]

#The below has to be TRUE for all if the re-ordering worked.
sp.infoOrdered$All==dimnames(bY.shape)[[3]]
```

### Attach metadata for further analysis. 
```{r}
#Attach metadata 
metadata <- read.csv("../1_Data (original data)/1_Raw/03_O_ana_-_All_Landmarked_Metadata.csv", header = T)

#Make CatNums from metadata the same as CatNums from sp.info 
metadata$CatNum <- gsub("-", "x", metadata$CatNum)  #Make metadata catnums same as sp.info
metadata$CatNum <- gsub("M0", "M", metadata$CatNum)  #Make metadata catnums same as sp.info

#Should not give NAs if the names of one data frame are present in the other
match(sp.info$CatNum,metadata$CatNum)

#Merge sp.info and metadata; adding rownames just to make it easier to check for matches
meta.info <- merge(sp.info, metadata, by = "CatNum", sort = F)
rownames (meta.info)= meta.info$CatNum
```

### Double cheacking Csize range to make their are no large outliers
```{r}
#Double check Csize range
Csizeorder<-sort((meta.info$Csize), decreasing=TRUE)
Csizeorder
```

# Setting the data frame for linear models
```{r}
#Define the data frame
AllometryGDF <- geomorph.data.frame(shape=bY.shape, size=meta.info$Csize, sex= meta.info$Sex, lat=meta.info$Latitude)


```


### Test for Bergmann's Rule and sexual dimorphims (i.e. is centroid size influenced by latitude or sex?)
```{r}
#Linear Model - Does size change with Lat?
LM_BR <- procD.lm(size~lat, iter = 499, data = AllometryGDF)
summary(LM_BR)

plot(LM_BR, type = "regression", reg.type = "PredLine", predictor =AllometryGDF$lat, pch = 19)

#Linear Model - Does size change with Sex?
LM_BR_Sex <- procD.lm(size~sex, iter = 499, data = AllometryGDF)
summary(LM_BR_Sex) #Yes! And a huge difference, too - 36% of size explained by sex.

plot(LM_BR, type = "regression", reg.type = "PredLine", predictor =AllometryGDF$sex, pch = 19)

```

### Allometry analyses (Does shape change with size?)
```{r}
#Does shape change with size?
Allom_Simple <-procD.lm(shape~size, iter = 499, data = AllometryGDF)
summary(Allom_Simple) #Yes- nearly 19% of shape variation due to size

#Plot
plot(Allom_Simple, type = "regression", reg.type = "RegScore", predictor = AllometryGDF$size, pch = 19)
```

## Is the allometry correlated with sex; latitude; population?

### Is the allometry seen in sex? (Part 1)
```{r}
#Allometry (linear model) with sex as an interaction 
Allom_Sex <-procD.lm(shape~size*sex, iter = 499, data = AllometryGDF)
summary(Allom_Sex) #No sig. interaction

#Allometry (linear model) with no interaction 
Allom_Sex_NoInter <-procD.lm(shape~size+sex, iter = 499, data = AllometryGDF)
summary(Allom_Sex_NoInter) 

#Make plot colour scheme
color.key <- c("Red","Blue", "Black")
grp <- as.factor(meta.info$Sex)
names(color.key) <- sort(unique(grp))
grp.col <- color.key[match(grp, names(color.key))]

#Plot 
plot(Allom_Sex_NoInter, type = "regression", reg.type = "RegScore", predictor =AllometryGDF$size, pch = 19, col= grp.col)
legend("bottomright", levels(meta.info$Sex), col=grp.col, pch = 19)

plot(Allom_Sex_NoInter, type = "regression", reg.type = "PredLine", predictor =AllometryGDF$size, pch = 19, col= grp.col)
legend("bottomright", levels(meta.info$Sex), col=grp.col, pch = 19)
```

## There is a significant difference in allometric intercept but not slope (i.e. no interaction) between sexes; this means that male platypus......

### Is the allometry  seen in individual sex? (Part 2)
```{r}
#Allometry with individual Sex as an interaction - Males
index.m <- which(meta.info$Sex == "Male")
metadata.m <- meta.info[index.m, ]
shape.m <- bY.shape[, , index.m]
AllometryGDF_Male <- geomorph.data.frame(shape=shape.m, size=metadata.m$Csize, sex= metadata.m$Sex)

Allom_Sex_M <-procD.lm(shape~size, iter = 499, data = AllometryGDF_Male)
summary(Allom_Sex_M)

#Allometry with individual Sex as an interaction - Females

#THE BELOW IS A START FOR MAKING A GDF FRAME WITH JUST MALES AND FEMALES. MAKE THAT AND RE-RUN TEH SEXUAL DIMORPHISM ANALYSES. 
index.f <- c(which(meta.info$Sex == "Female"), which(meta.info$Sex == "Male"))

metadata.f <- meta.info[index.f, ]
shape.f <- bY.shape[, , index.f]
AllometryGDF_Female <- geomorph.data.frame(shape=shape.f, size=metadata.f$Csize, sex= metadata.f$Sex)

Allom_Sex_F <-procD.lm(shape~size, iter = 499, data = AllometryGDF_Female)
summary(Allom_Sex_F) 

#Weight vs Centroid size - very signifcant 
summary(lm(meta.info$Csize~meta.info$Weight..g.))

plot(meta.info$Csize~meta.info$Weight..g.,col=factor(meta.info$Sex))
legend("bottomright", levels(meta.info$Sex), col=c("black", "red", "green"), pch = 1)
```

### Is the allometry seen in latitude?
```{r}
#Allometry (linear model) with interaction 
Allom_Lat <-procD.lm(shape~size*lat, iter = 499, data = AllometryGDF)
summary(Allom_Lat)

#Allometry (linear model) with no interaction 
Allom_Lat_NoInter <-procD.lm(shape~size+lat, iter = 499, data = AllometryGDF)
summary(Allom_Lat_NoInter)
#Significant p-vaule though little residual significance

#Latitude and Centroid size
summary(lm(meta.info$Csize~meta.info$Latitude))
#Not significant
```

### Is the allometry seen in populations? (Part 1)
```{r}
#Define a new general data frame
AllometryGDF_Pop <- geomorph.data.frame(shape=bY.shape, size=meta.info$Csize, pop= meta.info$Population)

#Allometry (linear model) with interaction 
Allom_Pop <-procD.lm(shape~size*pop, iter = 499, data = AllometryGDF_Pop)
summary(Allom_Pop)

#Allometry (linear model) with no interaction 
Allom_Pop_NoInter <-procD.lm(shape~size+pop, iter = 499, data = AllometryGDF_Pop)
summary(Allom_Pop_NoInter)

#Plot
plot(Allom_Pop_NoInter, type = "regression", reg.type = "PredLine", predictor =AllometryGDF_Pop$size, pch = 19)

plot(Allom_Pop_NoInter, type = "regression", reg.type = "RegScore", predictor =AllometryGDF_Pop$size, pch = 19)

#Does Shape change with population

#Allometry (linear model) with no interaction looking at shape vs pop
Allom_PopShapeSize <-procD.lm(shape~pop+size, iter = 499, data = AllometryGDF_Pop)
summary(Allom_PopShapeSize)

#Allometry (linear model) looking at shape vs pop
Allom_PopShape <-procD.lm(shape~pop, iter = 499, data = AllometryGDF_Pop)
summary(Allom_PopShape)
```

### Is the allometry seen in individual populations? (Part 2)
```{r}
#Allometry with individual populations - Mainland
index.main <- which(meta.info$Population == "Mainland")
names (index.main) <- meta.info$All[which(meta.info$Population == "Mainland")] 
metadata.main <- meta.info[index.main, ]
shape.main <- bY.shape[, , index.main]

names(index.main)==dimnames(shape.main)[[3]]  #double check to match up

#Define a new general data frame
AllometryGDF_Main <- geomorph.data.frame(shape=shape.main, size=metadata.main$Csize, pop= metadata.main$Population) 
Allom_Pop_Main <-procD.lm(shape~size, iter = 499, data = AllometryGDF_Main)
summary(Allom_Pop_Main)  
#Significant and more resduals

#Allometry with individual populations - Tasmanian
index.tas <- which(meta.info$Population == "Tasmanian")
names (index.tas) <- meta.info$All[which(meta.info$Population == "Tasmanian")] 
metadata.tas <- meta.info[index.tas, ]
shape.tas <- bY.shape[, , index.tas]

names(index.tas)==dimnames(shape.tas)[[3]]  #double check to match up

#Define a new general data frame
AllometryGDF_Tas <- geomorph.data.frame(shape=shape.tas, size=metadata.tas$Csize, pop= metadata.tas$Population) 

Allom_Pop_Tas <-procD.lm(shape~size, iter = 499, data = AllometryGDF_Tas)
summary(Allom_Pop_Tas)  
```

### Is the allometry seen in individual populations? - Mainland vs Tasmania (Part 3)
```{r}
#Allometry looking at Mainland populations vs the Tasmanian population
index_MT <-c(which(meta.info$Population == "Mainland"), which(meta.info$Population =="Tasmanian"))
names(index_MT) <- meta.info$All[index_MT]
metadata_MT <- meta.info[index_MT, ]
shape_MT <- bY.shape[, , index_MT]

names(index_MT)==dimnames(shape_MT)[[3]]  #double check to match up

AllometryGDF_MT <- geomorph.data.frame(shape=shape_MT, size=metadata_MT$Csize, pop= metadata_MT$Population) #Define a new general data frame

#Allometry (linear model) with interaction 
Allom_Pop_MT <-procD.lm(shape~size*pop, iter = 499, data = AllometryGDF_MT)
summary(Allom_Pop_MT)
#No significant interaction means that slopes are not different

#Allometry (linear model) with no interaction 
Allom_Pop_MT_NoInter <-procD.lm(shape~size+pop, iter = 499, data = AllometryGDF_MT)
summary(Allom_Pop_MT_NoInter)

#Plot
plot(Allom_Pop_MT_NoInter, type = "regression", reg.type = "PredLine", predictor =AllometryGDF_MT$size, pch = 19)

plot(Allom_Pop_MT_NoInter, type = "regression", reg.type = "RegScore", predictor =AllometryGDF_MT$size, pch = 19)
```

### Is the allometry seen in individual populations? - Mainland vs West Victoria (Part 4)
```{r}
#Allometry looking at Mainland populations vs the West Victoria population
index_MWV <-c(which(meta.info$Population == "Mainland"), which(meta.info$Population =="West Victoria"))
names(index_MWV) <- meta.info$All[index_MWV]
metadata_MWV <- meta.info[index_MWV, ]
shape_MWV <- bY.shape[, , index_MWV]

names(index_MWV)==dimnames(shape_MWV)[[3]]  #double check to match up

AllometryGDF_MWV <- geomorph.data.frame(shape=shape_MWV, size=metadata_MWV$Csize, pop= metadata_MWV$Population) #Define a new general data frame

#Allometry (linear model) with interaction 
Allom_Pop_MWV <-procD.lm(shape~size*pop, iter = 499, data = AllometryGDF_MWV)
summary(Allom_Pop_MWV)
#No significant interaction means that slopes are not different

#Allometry (linear model) with no interaction 
Allom_Pop_MWV_NoInter <-procD.lm(shape~size+pop, iter = 499, data = AllometryGDF_MWV)
summary(Allom_Pop_MWV_NoInter)

#Plot
plot(Allom_Pop_MWV_NoInter, type = "regression", reg.type = "PredLine", predictor =AllometryGDF_MWV$size, pch = 19)
#pretty much the exact same regression line - No difference
```

### Plot PCA
```{r}
# Plot 3D shape into a PCA plot
pca_general <- plotTangentSpace(bY.shape)

#Summare of PCA
pca_general$pc.summary

#Look at difference
plotRefToTarget(pca_general$pc.shapes$PC1min,pca_general$pc.shapes$PC1max, method="vector",pt.bg="pink")
```

### PCA plotting for sex
```{r}
#Make a colour key for sex
colour_pca_sex <- c("Black", "Red", "Purple")
grp <- as.factor(meta.info$Sex)
names(colour_pca_sex) <- sort(unique(grp))
grp_col_pca_sex <- colour_pca_sex[match(grp, names(colour_pca_sex))]

#Plot PCA of Sex
plot(x = pca_general$pc.scores[, 1],
                         y = pca_general$pc.scores[, 2], 
                         xlab = "PC1", 
                         ylab = "PC2",
                         asp = TRUE,
                         col = grp_col_pca_sex, 
                         pch = 16 )
legend("bottomright", levels(meta.info$Sex), col=colour_pca_sex, pch = 19)
```

### PCA plotting for population
```{r}
#Make a colour key for popluation
colour_pca_pop <- c("Red", "Black", "Blue", "Green")
grp <- as.factor(meta.info$Population)
names(colour_pca_pop) <- sort(unique(grp))
grp_col_pca_pop <- colour_pca_pop[match(grp, names(colour_pca_pop))]

#Plot PCA of population
plot(x = pca_general$pc.scores[, 1],
                         y = pca_general$pc.scores[, 2], 
                         xlab = "PC1", 
                         ylab = "PC2",
                         asp = TRUE,
                         col = grp_col_pca_pop, 
                         pch = 16 )
legend("topleft", levels(meta.info$Population), col=colour_pca_pop, pch = 19)
```

### Centroid size and PC1
```{r}
#Plot centroid size with PC1
plot(pca_general$pc.scores[,1]  ~meta.info$Csize)

#Summary
summary(lm(pca_general$pc.scores[,1]  ~meta.info$Csize))
```
